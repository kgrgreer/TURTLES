{ input parser output let input 0 #F #F {} PStream :ps |
  " expect: " .$ input .$ "  -> " .$ output .$ .nl
  ps parser () { result |
    output
      { |
        result
          { | result .value output =$ t .score .$ .nl }
          { | #F t .score .$ .nl }
        ifelse
      }
      { | result ! t .score .$ .nl }
    ifelse
  } ()
  .nl
} ::testp


" Literal Parser" section

" thisXXX1"  'this lit  'this  testp
" thisXXX2"  'that lit  #F     testp


" Literal Map Parser" section
" thisXXX1"  'this 'foo litMap  'foo  testp


" Optional Parser" section
'thisthenthat  'this lit      'this testp
'thisthenthat  'this lit opt  'this testp


" Repeat Parser" section
'AAAB  'A lit 0 repeatp joinp  'AAA  testp
'AAAB  'A lit 4 repeatp        #F    testp


" Seq Parser" section
'thisthenthat0123  [ 'this lit 'then lit ] seq joinp  'thisthen   testp
'thisthenthat0123  [ 'this 'then ] seq joinp          'thisthen   testp
'(this)            [ '( 'this ') ] 1 seq1             'this       testp


" Alt Parser" section
'thisthenthat0123  [ 'think 'this ] alt 'this testp


" Range Parser" section
'567  `0 `9 range { | c>$ } mapp  '5  testp
'abc  `0 `9 range   #F  testp


" Repeat Parser" section
'567  `0 `9 range star { | cjoin } mapp  '567  testp


" Opt(ional) Parser" section
'this   'that lit       #F    testp
'this   'this lit       'this testp
'this   'that lit opt   { v | #F v = { | 'skip } if } mapp 'skip    testp
'this   'this lit opt   'this testp


" chars Parser" section
'thisthenthat0123   'this chars      't        testp
'thisthenthat0123   'this chars star joinp 'thisth   testp


" !chars Parser" section
'thisthenthat0123   '0123456789 !chars              't              testp
'thisthenthat0123   '0123456789 !chars star joinp   'thisthenthat   testp


" Delimiter Parser" section
" 1,2,3  "  " `0 `9 range () .value " 49 testp
" 1,2,3  "  " [ `0 `9 range ', lit ] 0 seq1 () .value " 49 testp
" 1,2,3, "  " [ `0 `9 range ', lit ] 0 seq1 star () .value cjoin '123 =$ " #T testp
" 1,2,3, "  " `0 `9 range ', lit delim () .value cjoin '123 =$ " #T testp


/*
// doesn't work without some kind of wildcard parser
" Not Parser" section
" this then that." " [ '. lit chars notp ] 1 seq1 () guru .value .$ #T " #T testp
*/


" Map Parser" section
" one" " 'one lit { | switch 'one 1 'two 2 3 end } mapp () .value " 1 testp
" two" " 'two lit { | switch 'one 1 'two 2 3 end } mapp () .value " 2 testp


'Grammar section
{ let
  call: { m o | o m o () () } ; // Call the method with specified name
  this:   'this lit ;
  that:   'that lit ;
  repeat: 'a lit 1 repeatp ;
  star1:  'a lit star ;
  plus1:  'a lit plus ;
  seq1:   [ 'abc lit 'def lit ] seq ;
  alt1:   [ 'abc lit 'def lit ] alt ;
  alt2:   [ 'this lit 'that lit ] alt ;
  alt3:   [ << this >> << that >> ] alt ;
  | { | ?? }
} () :grammar

{ input sym expected let input 0 #F #F grammar PStream :ps |
  " symbol: " .$ sym .$ "  input: " .$ input .$ .nl
  [ sym ps .call { | 'parse .$ .nl #T } { | 'no-parse .$ .nl #F } ifelse { | } expected t .testf ] drop
  .nl
} ::testg // test grammar


" thisthenthat0123" 'this  #T testg
" thisthenthat0123" 'that  #F testg
'aaaaaa 'repeat #T testg
'aaaaaa 'star1 #T testg
'aaaaaa 'plus1 #T testg
'abcdef 'seq1 #T testg
 'abc 'alt1 #T testg
 'def 'alt1 #T testg
'this 'alt2 #T testg
'that 'alt2 #T testg
'this 'alt3 #T testg
'that 'alt3 #T testg
