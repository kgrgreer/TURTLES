{ input parser expected let input 0 false false PStream :ps |
  " input: " .$ input .$ .nl
  [ ps parser expected t .test ] drop
  .nl
} ::testp


" Literal Parser" section
" thisthenthat0123 " " 'this lit () .value 'this =$ " #T testp
" thisthenthat0123 " " 'that lit ()        " #F testp


" Optional Parser" section
" thisthenthat " " 'this lit ()     .value 'this =$ " #T testp
" thisthenthat " " 'this lit opt () .value 'this =$ " #T testp


" Repeat Parser" section
" AAAB " " 'A lit 0 repeat () .value join len " 3  testp
" AAAB " " 'A lit 4 repeat ()                 " #F testp


" Seq Parser" section
" thisthenthat0123 " " [ 'this lit 'then lit ] seq () .value join 'thisthen =$ " true testp
" thisthenthat0123 " " [ 'this     'then     ] seq () .value join 'thisthen =$ " true testp


" Alt Parser" section
" thisthenthat0123 " " [ 'think 'this ] alt () .value 'this =$ " true testp


(*
" Range Parser" section
`0 `9 range :rangeparser
ps rangeparser () .$
'a 0 charAt 'z 0 charAt range :rangeparser
ps rangeparser () .value charCode .$ .nl
*)

(*
" Repeat Parser" section
`a `z range 1 repeat :repeatparser
ps repeatparser () .value { x | x charCode } map join .$ .nl
*)

(*
'parse-"that" .$
ps 'that lit () .$ .nl
ps 'that lit opt () .$ .nl

'thisthen print
ps [ 'this opt 'then ] seq () .toString .$ .nl
*)

" AnyChar Parser" section
" thisthenthat0123 "  " 'this anyChar      () .value 't =$ " #T testp
" thisthenthat0123 "  " 'this anyChar star () .value join 'thisth =$ " #T testp

" NotChars Parser" section
" thisthenthat0123 "  " '0123456789 notChars      () .value 't =$ " #T testp
" thisthenthat0123 "  " '0123456789 notChars star () .value join 'thisthenthat =$ " #T testp
