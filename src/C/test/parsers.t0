{ input parser expected let input 0 #F #F {} PStream :ps |
  " input: " .$ input .$ .nl
  [ ps parser expected t .test ] drop
  .nl
} ::testp


" Literal Parser" section
" thisthenthat0123" " 'this lit () .value 'this =$ " #T testp
" thisthenthat0123" " 'that lit ()                 " #F testp


" Literal Map Parser" section
// litMap


" Optional Parser" section
" thisthenthat " " 'this lit ()     .value 'this =$ " #T testp
" thisthenthat " " 'this lit opt () .value 'this =$ " #T testp


" Repeat Parser" section
" AAAB " " 'A lit 0 repeatp () .value join len " 3  testp
" AAAB " " 'A lit 4 repeatp ()                 " #F testp


" Seq Parser" section
" thisthenthat0123 " " [ 'this lit 'then lit ] seq () .value join 'thisthen =$ " #T testp
" thisthenthat0123 " " [ 'this     'then     ] seq () .value join 'thisthen =$ " #T testp
" (this) " " [ '( 'this ') ] 1 seq1 () .value 'this =$ " #T testp


" Alt Parser" section
" thisthenthat0123 " " [ 'think 'this ] alt () .value 'this =$ " #T testp


" Range Parser" section
" 567 " " `0 `9 range () .value " `5 testp
" abc " " `0 `9 range ()        " #F testp


" Repeat Parser" section
" 567 " " `0 `9 range star () .value cjoin '567 =$ " #T testp


" Opt(ional) Parser" section
'this " 'that lit () " #F testp
'this " 'this lit () .value 'this =$ " #T testp
'this " 'that lit opt () .value " #F testp
'this " 'this lit opt () .value 'this =$ " #T testp


" chars Parser" section
" thisthenthat0123 "  " 'this chars      () .value 't =$ " #T testp
" thisthenthat0123 "  " 'this chars star () .value join 'thisth =$ " #T testp


" !chars Parser" section
" thisthenthat0123 "  " '0123456789 !chars      () .value 't =$ " #T testp
" thisthenthat0123 "  " '0123456789 !chars star () .value join 'thisthenthat =$ " #T testp


" Delimiter Parser" section
" 1,2,3  "  " `0 `9 range () .value " 49 testp
" 1,2,3  "  " [ `0 `9 range ', lit ] 0 seq1 () .value " 49 testp
" 1,2,3, "  " [ `0 `9 range ', lit ] 0 seq1 star () .value cjoin '123 =$ " #T testp
" 1,2,3, "  " `0 `9 range ', lit delim () .value cjoin '123 =$ " #T testp


/*
// doesn't work without some kind of wildcard parser
" Not Parser" section
" this then that." " [ '. lit chars notp ] 1 seq1 () guru .value .$ #T " #T testp
*/


" Map Parser" section
" one" " 'one lit { | switch 'one 1 'two 2 3 end } mapp () .value " 1 testp
" two" " 'two lit { | switch 'one 1 'two 2 3 end } mapp () .value " 2 testp
