{ input parser expected let input 0 false false PStream :ps |
  " input: " .$ input .$ .nl
  [ ps parser expected t .test ] drop
  .nl
} ::testp


" Literal Parser" section
" thisthenthat0123" " 'this lit () .value 'this =$ " #T testp
" thisthenthat0123" " 'that lit ()        " #F testp


" Optional Parser" section
" thisthenthat " " 'this lit ()     .value 'this =$ " #T testp
" thisthenthat " " 'this lit opt () .value 'this =$ " #T testp


" Repeat Parser" section
" AAAB " " 'A lit 0 repeat () .value join len " 3  testp
" AAAB " " 'A lit 4 repeat ()                 " #F testp


" Seq Parser" section
" thisthenthat0123 " " [ 'this lit 'then lit ] seq () .value join 'thisthen =$ " true testp
" thisthenthat0123 " " [ 'this     'then     ] seq () .value join 'thisthen =$ " true testp


" Alt Parser" section
" thisthenthat0123 " " [ 'think 'this ] alt () .value 'this =$ " true testp


" Range Parser" section
" 567 " " `0 `9 range () .value " `5 testp
" abc " " `0 `9 range ()        " false testp

" Repeat Parser" section
" 567 " " `0 `9 range star () .value [ swap { | charCode } do ] join '567 =$ " true testp

" Opt(ional) Parser" section
(*
'parse-"that" .$
ps 'that lit () .$ .nl
ps 'that lit opt () .$ .nl

'thisthen print
ps [ 'this opt 'then ] seq () .toString .$ .nl
*)

exit

" AnyChar Parser" section
" thisthenthat0123 "  " 'this anyChar      () .value 't =$ " #T testp
" thisthenthat0123 "  " 'this anyChar star () .value join 'thisth =$ " #T testp

" NotChars Parser" section
" thisthenthat0123 "  " '0123456789 notChars      () .value 't =$ " #T testp
" thisthenthat0123 "  " '0123456789 notChars star () .value join 'thisthenthat =$ " #T testp
