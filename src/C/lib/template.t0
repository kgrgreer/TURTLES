'lib/parsers.t0 require

{ ps | ps .head { | ps .head charCode dup .$ ps .tail .:value } { | 'EOF .$ .nl #F } ifelse } :charp // Does the tail value need to be set? Same for anyChar and notChars

{ let
  { o | [ o .Code o .Text ] alt star joinp { s | [ "  [ " '""" "  " s ` '"""  "  ] join """ ] join } mapp } :Template
  { o | [ '{{{ o .CodeBody '}}} ] 1 seq1 { c | [ ` '""" ` c ` '""" ` ] join } mapp } :Code
  { o | [ '}}} lit notp charp ] 1 seq1 plus joinp } :CodeBody
  { o | charp } :Text
  | { m | 'method: .$ m .$ .nl m ?? }
} () :TemplateParser

{ input let input 0 #F #F PStream :ps 0 :result |
  " input: " .$ input .$ .nl
  ps TemplateParser .Template () :result
  result
    { | 'value: .$ result .value .$ result .value }
    { | " syntax error" .$ }
  ifelse
  .nl
} ::template

// " a b cdef " template

// " {{{code}}}" template

// " not code" template

// " not code {{{code}}} more not code" template

// Idea: <strlen> #$ strings starts here without escaping
'((((((((((((((((foo .$ .nl


// '' """ not code {{{ " hello" }}} more not code """ template ''
// .$ .$ .$
'((((((((((((bar .nl

{ str | str template emit } :!templateC

{ |
  i{ """ {{{ nl }}} not code {{{ " hello" }}} more not code""" }i templateC
} :test

{ | test () .$  .nl } 10 repeat
