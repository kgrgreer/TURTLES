{ let { | key } :delegate |
  { | delegate } ::getKey
  { delegate' | delegate' :delegate delegate ::_key_ } ::setKey
  { | delegate () } ::key
} ()

{ | { | key 10 != } { | } while } :!//
// Now we have C++-style comments

// //////////////////////////////////////////////////////////////////////////
// Prefix.t0
// T0 Language Features written in T0
// //////////////////////////////////////////////////////////////////////////

{ c b | { | c () ! } b while } ::until

{ let 0 :prev 0 :c | { | prev `* =  c `/ =  & } { | c :prev key :c } until } :!/*
/* Now we have C-style comments */

{ let 0 :prev 0 :c | { | prev `* =  c `) =  & } { | c :prev key :c } until } :!(*
(* Now we have Beta-style comments, let's just use to comment out code *)
// Maybe {* *} would be better for code comments?

{ | clearStack cls } ::clear

1 1 = :true
1 2 = :false
{ } :nil // define 'nil', like doing nil = new Object() in Java/JS
nil :nop // TODO: remove
nil :{}  // Identity Function

{ n | 0 n - } ::neg
{ n | n n 0 < { | neg } if } ::abs

// Standard Forth-like Stack Functions
// { _ } ::drop // coded natively
{ _ _ } ::drop2
{ _ _ _ } ::drop3
{ a | a a } ::dup
{ a b | a b a b } ::dup2
{ a b | b a } ::swap
{ a b | a b a } ::over
{ a b c | b c a } ::rot

13 charCode :cr
9  charCode :tab { | tab .$ } ::.tab  // or name \t?
10 charCode :nl  { | nl  .$ } ::.nl   // or name \n?
"  " :`          { | `   .$ } ::.`

// { start end block | { | start end <= } { | start block () start++ } while } ::for // coded natively

// Standard High-Order Functions
{ a f | { | a f () } } ::curry
{ a f | 0  a # 1 - { i | a i @ f () } for } ::do
{ a f | a # 1 -  0 { i | a i @ f () } for } ::doReverse
{ a | [ a {} doReverse ] } ::reverse
{ a f | [ a f do ] } ::map
{ a v f | v a f do } ::reduce
{ a p | [ a { e | e p () { | e } if } do ] } ::filter
{ a | a \0 { | >$ +$ } reduce } ::join // join an array of strings into a single string
{ a | a \0 { | c>$ +$ } reduce } ::cjoin // join an array of chars int a string
{ a w let true :first | (* a ! { | \0 ret<- } if *) a {} filter { i | first { | false :first i } { | w i +$ } ifelse } map join } ::joinWith // join with a specified delimiter
{ a | a "  " joinWith } ::joins // join, space separated, removing false values


// String Literals
// These appear to work but break things for unknown reason. TODO: fix
// { let 0 :c | [ { | c `" = } { | key :c c charCode } until drop ] join } :!" // ISSUE: Doesn't work?
// { let 0 :prev 0 :c | [ { | prev `" =  c `" =  & } { | c :prev key :c c charCode } until drop2 ] join } :!""
// { let 0 :c'' 0 :c' 0 :c | [ { | c'' `" =  c' `" =  c `" =  & & } { | c' :c''  c :c'  key :c  c charCode } until drop3 ] join } :!"""


// TODO: split

{ v | { | switch 'get { this | v } { v' this | v' :v } end } } ::Let

// Set Collection
{ | switch
  '? { v this | false }
  'top { this | nil }
  'pop { this | null this }
  { v this | v this ListNode }
end } :EmptyList

{ value parent | { | switch
  '? { v this | v value =$ { | v parent .? } || }
  'top { this | value }
  'pop { this | value parent }
  /* handles add and push */ { v this | v this ListNode }
end } } ::ListNode

{ let EmptyList :set | { | switch
  '? { v this | v set .? }
  'top { this | set .top }
  'pop { this | set .pop :set }
  /* handles add and push */ { v this | v set .add :set } // Could check if already in set first
end } } dup ::Set ::Stack // Stack and Set use the same LinkedList implementation


// Meta-programming Support
{ s eof let getKey :oldKey 0 :i s ` +$ :s s len :l |
  { |
    cond
      { | i l = } { | oldKey setKey eof }
      { | i l < } { | s i charAt }
      { | true  } { | 32 }
    end ()
    i++
  } setKey
} ::emit_

{ | 32 emit_ } ::emit
{ | -1 emit_ eval_ } ::eval

// Array Functions
{ a b | [ a {} do b {} do ] } ::+[] // concatenate two arrays
{ a | [ a {} do ] } ::clone[]
{ a start end | start end { i | a i @ } for } ::slice

// String Functions
{ str s e | [ s e 1 - { i | str i charAt charCode } for ] join } ::substring
{ s p padChar | [ { | padChar } p s len - repeat s ] join } ::lpadWith
{ | ` lpadWith } ::lpad
{ s p padChar | [ s { | padChar } p s len - repeat ] join } ::rpadWith
{ | ` rpadWith } ::rpad

// Range Functions
{ start i end | i start >  i end <  & } ::<_<
{ start i end | i start >= i end <= & } ::<=<

// Experimental Renames
{ | charCode } ::c>$
true  :#T
false :#F


{ let Set :loaded |
  { file |
    .nl
    file loaded .?
      { | " not reloading " .$ file .$ }
      { |
        " loading " .$ file .$ .nl
        file require_
        file loaded .add
      }
    ifelse
  }
} () ::require
