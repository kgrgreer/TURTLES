{ let { | key } :delegate |
  { | delegate } ::getKey
  { delegate' | delegate' :delegate delegate ::_key_ } ::setKey
  { | delegate () } ::key
} ()

{ | { | key 10 != } { | } while } :!//
// Now we have C++-style comments

// //////////////////////////////////////////////////////////////////////////
// Prefix.t0
// T0 Language Features written in T0
// //////////////////////////////////////////////////////////////////////////

{ c b | { | c () ! } b while } ::until

{ let 0 :prev 0 :c | { | prev 42 =  c 47 =  & } { | c :prev key :c } until } :!/*
/* Now we have C-style comments */

{ let 0 :prev 0 :c | { | prev 42 =  c 41 =  & } { | c :prev key :c } until } :!(*
(* Now we have Beta-style comments, let's just use to comment out code *)
// Maybe {* *} would be better for code comments?

{ | clearStack cls } ::clear

1 1 = :true
1 2 = :false
{ } :nil // define 'nil', like doing nil = new Object() in Java/JS
nil :nop // TODO: remove
nil :{}  // Identity Function

{ n | 0 n - } ::neg
{ n | n n 0 < { | neg } if } ::abs

// Standard Forth-like Stack Functions
// { _ } ::drop // coded natively
{ _ _ } ::drop2
{ a | a a } ::dup
{ a b | a b a b } ::dup2
{ a b | b a } ::swap
{ a b | a b a } ::over
{ a b c | b c a } ::rot

13 charCode :cr
9  charCode :tab { | tab .$ } ::.tab  // or name \t?
10 charCode :nl  { | nl  .$ } ::.nl   // or name \n?
"  " :`          { | `   .$ } ::.`

// { start end block | { | start end <= } { | start block () start++ } while } ::for // coded natively

// Standard High-Order Functions
{ a f | { | a f () } } ::curry
{ a f | 0  a # 1 - { i | a i @ f () } for } ::do
{ a f | a # 1 -  0 { i | a i @ f () } for } ::doReverse
{ a | [ a {} doReverse ] } ::reverse
{ a f | [ a f do ] } ::map
{ a v f | v a f do } ::reduce
{ a p | [ a { e | e p () { | e } if } do ] } ::filter
{ a | a " " { | >$ +$ } reduce } ::join // join an array of strings into a single string
{ a | a " " { | c>$ +$ } reduce } ::cjoin // join an array of chars int a string
{ a w let true :first | (* a ! { | " " ret<- } if *) a {} filter { i | first { | false :first i } { | w i +$ } ifelse } map join } ::joinWith // join with a specified delimiter
{ a | a "  " joinWith } ::joins // join, space separated, removing false values

// TODO: split

{ v | { | switch 'get { this | v } { v' this | v' :v } end } } ::Let

// Meta-programming Support
{ s eof let getKey :oldKey 0 :i s ` +$ :s s len :l |
  { |
    cond
      { | i l = } { | oldKey setKey eof }
      { | i l < } { | s i charAt }
      { | true  } { | 32 }
    end ()
    i++
  } setKey
} ::emit_

{ | 32 emit_ } ::emit
{ | -1 emit_ eval_ } ::eval

// Array Functions
{ a b | [ a {} do b {} do ] } ::+[] // concatenate two arrays
{ a | [ a {} do ] } ::clone[]
{ a start end | start end { i | a i @ } for } ::slice

// String Functions
{ str s e | [ s e 1 - { i | str i charAt charCode } for ] join } ::substring
{ s p padChar | [ { | padChar } p s len - repeat s ] join } ::lpadWith
{ | ` lpadWith } ::lpad
{ s p padChar | [ s { | padChar } p s len - repeat ] join } ::rpadWith
{ | ` rpadWith } ::rpad

// Experimental Renames
{ | charCode } ::c>$
true  :#T
false :#F
