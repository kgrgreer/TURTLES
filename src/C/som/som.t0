// som.t0
// SOM to T0 Compiler

'lib/template.t0 require

i{
{ let 0 :prev 0 :c |
  [ { | prev `> = c `> = & } { | c :prev key :c c c>$ } until drop2 ] join
  { name |
    ${ { | o .{{ name }} () } }$ dup .$
    emit
  } ()
} :!<<
}i


// translated from: https://github.com/SOM-st/SOM/blob/master/specification/SOM.g4
{ let
  call:                { m o | o m o () () } ; // Call the method with specified name, used for testing
  program:             { o | << classdef >> plus } ;
  classdef:            { o | [
    << identifier >> '= << superclass >> '(
      << instanceFields >>
      << method >> star
      [ << Separator >>  << classFields >> opt << method >> star ] seq opt
    ')
  ] seq } ;
  superclass:          { o | << Identifier >> opt } ;
  instanceFields:      { o | << fields >> } ;
  classFields:         { o | << fields >> } ;
  fields:              { o | [ '| << variable >> star '| ] 1 seq1 opt } ;
    method:              { o | [ << pattern >> '= [ << STPrimitive >>  << methodBlock >> ] alt ] seq } ;
    pattern:             { o | [ << keywordPattern >>  << binaryPattern >>  << unaryPattern >> ] alt } ;
  unaryPattern:        { o | << unarySelector >> } ;
  binaryPattern:       { o | [ << binarySelector >>  << argument >> ] seq } ;
    keywordPattern:      { o | [ << keyword >>  << argument >>> ] seq plus } ;
    methodBlock:         { o | [ '( << blockContents >> opt ') ] 1 seq1 } ;
  unarySelector:       { o | [ << identifier >> ': lit notp ] 0 seq1 } ;
  binarySelector:      { o | << OperatorSeq >> } ;
  identifier:          { o | [ << STPrimitive >>  << Identifier >> ] alt } ;
  keyword:             { o | << Keyword >> } ;
  argument:            { o | << variable >> } ;
    blockContents:       { o | [ [ '| << localDefs >> '| ] 1 seq1 opt  <<  blockBody >> ] seq } ;
    localDefs:           { o | << variable >> star } ;
    blockBody:           { o | [ << blockBodyReturn >>  << blockBodyExpression >> ] alt } ;
    blockBodyReturn:     { o |  [ '^ <<  result >> ] 1 seq1 } ;
    blockBodyExpression: { o | [ << expression >> [ '. << blockBody >> opt ] 1 seq1 opt ] seq } ;
    result:              { o | [ << expression >> '. lit opt ] 0 seq1 } ;
    expression:          { o | [ << assignation >>  << evaluation >> ] alt } ;
    assignation:         { o | [ << assignments >>  << evaluation >> ] seq } ;
    assignments:         { o | << assignment >> plus } ;
    assignment:          { o | [ << variable >> ':= ] 0 seq1 } ;
    evaluation:          { o | [ << primary >>  << messages >> opt ] seq } ;
    primary:             { o | [ << variable >>   << nestedTerm >>  << nestedBlock >>  << .literal >> ] alt } ;
  variable:            { o | << identifier >> } ;
    messages:            { o | [ << unaryMessage >> star << .binaryMessage >> star << keywordMessage >> opt ] seq } ;
    unaryMessage:        { o | << unarySelector >> } ;
    binaryMessage:       { o | [ << binarySelector >>  << binaryOperand >> ] seq } ;
    binaryOperand:       { o | [ << primary >>  << unaryMessage >> star ] seq } ;
    keywordMessage:      { o | [ << keyword >>  << formula >> ] seq plus } ;
    formula:             { o | [ << binaryOperand >>  << binaryMessage >> star ] seq } ;
    nestedTerm:          { o | [ '( << expression >> ') ] 1 seq1 } ;
    literal:             { o | [ << literalArray >>  << literalSymbol >>  << literalString >>  << literalNumber >> ] alt } ;
    literalArray:        { o | [ '# '( << literal >> star ') ] 2 seq1 } ;
  literalNumber:       { o | << Number >> } ;
    literalSymbol:       { o | [ '# [ << string >>  << selector >> ] alt ] 1 seq1 tok } ;
  literalString:       { o | << STString >> } ;
    selector:            { o | [ << binarySelector >>  << keywordSelector >>  << unarySelector >> ] alt } ;
    keywordSelect2:     { o | << KeywordSeq >> } ;
    keywordSelector:     { o | << KeywordSeq >> } ;
  string:              { o | << STString >> } ;
    nestedBlock:         { o | [ '[  << blockPattern >> opt  << blockContents >> opt '] ] seq } ;
    blockPattern:        { o | [ << blockArguments >> '| ] 0 seq1 } ;
    blockArguments:      { o | [ " :" << argument >> ] seq joinp plus } ;
  //  Number:            { o | [ '- lit opt << Num >> plus [ '. << Num >> plus ] seq opt ] seq tok } ;
  Number:              { o | [ '- lit opt << Num >> plus joinp [ '. << Num >> plus joinp ] seq joinp opt ] seq { | { | } filter join $># } mapp tok } ; // $># only works with integers
  Alpha:               { o | [ `a `z range `A `Z range ] alt { | c>$ } mapp } ;
  Num:                 { o | `0 `9 range { | c>$ } mapp } ;
  AlphaNum:            { o | [ << Alpha >>  << Num >> ] alt } ;
  Identifier:          { o | [ << Alpha >>  << AlphaNum >> star joinp ] seq joinp tok } ;
  STPrimitive:         { o | 'primitive lit } ;
  Separator:           { o | '- lit 4 repeatp tok } ;
  OperatorSeq:         { o | '~&|*/\+<>,%@-= chars plus joinp } ;
  Keyword:             { o | [ << Identifier >> ': ] seq joinp tok } ;
  KeywordSeq:          { o | << Keyword >> plus joinp tok } ;
  STStringChar:        { o | [
    '\b  8 c>$ litMap // backspace
    '\t  9 c>$ litMap // tab
    '\n 10 c>$ litMap // newline
    '\f 12 c>$ litMap // formfeed
    '\r 13 c>$ litMap // carriage return
    '\' 39 c>$ litMap // single quote
    '\\ 92 c>$ litMap // backslash
    //      '\0 litMap // zero byte character, doesn't work well with C strings
    '' !chars ] alt } ;
  STString:            { o | [ '' << STStringChar >> star '' ] 1 seq1 joinp } ;
  Comment:             { o | [ '" '" !chars star '" ] 1 seq1 tok } ;
  Whitespace:          { o | [ tab cr nl sp ] alt plus joinp tok } ;
    ignore:              { o | [ << Whitespace >>  << Comment >> ] alt plus tok } ;
  | { s | (* 'method: .$ s .$ .nl *) s ?? (* dup ! { | 'unknown-method .$ .nl } if *) }
} () :SOMParser
