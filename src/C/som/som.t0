// som.t0
// SOM to T0 Compiler

'lib/template.t0 require

// << name >> -> { | o .name () }
// i{
{ let 0 :prev 0 :c |
  [ { | prev `> = c `> = & } { | c :prev key :c c c>$ } until drop2 ] join
  { name |
    ${ { | o .{{ name }} () } }$ dup .$
    emit
  } ()
} :!<<
// }i

// !!!: Parsers are functions but methods are methods (take o). Should parsers be methods?

// translated from: https://github.com/SOM-st/SOM/blob/master/specification/SOM.g4
{ let
  call:                { m o | o m o () () } ; // Call the method with specified name, used for testing
  program:             { o | << classdef >> plus } ;
  classdef:            { o | [
    << identifier >> '= << superclass >> '(
      << instanceFields >>
      << method >> star
      [ << Separator >>  << classFields >> opt << method >> star ] seq opt
    ')
  ] seq } ;
  superclass:          { o | << Identifier >> opt } ;
  instanceFields:      { o | << fields >> } ;
  classFields:         { o | << fields >> } ;
  fields:              { o | [ '| << variable >> star '| ] 1 seq1 opt } ;
  method:              { o | [ << pattern >> '= [ << STPrimitive >>  << methodBlock >> ] alt ] seq } ;
  pattern:             { o | [ << keywordPattern >>  << binaryPattern >>  << unaryPattern >> ] alt } ;
  unaryPattern:        { o | << unarySelector >> } ;
  binaryPattern:       { o | [ << binarySelector >>  << argument >> ] seq } ;
  keywordPattern:      { o | [ << keyword >>  << argument >>> ] seq plus } ;
  methodBlock:         { o | [ '( << blockContents >> opt ') ] 1 seq1 } ;
  unarySelector:       { o | [ << identifier >> ': lit notp ] 0 seq1 } ;
  binarySelector:      { o | << OperatorSeq >> } ;
  identifier:          { o | [ << STPrimitive >>  << Identifier >> ] alt } ;
  keyword:             { o | << Keyword >> } ;
  argument:            { o | << variable >> } ;
  blockContents:       { o | [ [ '| << localDefs >> '| ] 1 seq1 opt  <<  blockBody >> ] seq } ;
  localDefs:           { o | << variable >> star } ;
  blockBody:           { o | [ << blockBodyReturn >>  << blockBodyExpression >> ] alt } ;
  blockBodyReturn:     { o |  [ '^ <<  result >> ] 1 seq1 } ;
  blockBodyExpression: { o | [ << expression >> [ '. << blockBody >> opt ] 1 seq1 opt ] seq } ;
  result:              { o | [ << expression >> '. lit opt ] 0 seq1 } ;
  expression:          { o | [ << assignation >>  << evaluation >> ] alt } ;
  assignation:         { o | [ << assignments >>  << evaluation >> ] seq } ;
  assignments:         { o | << assignment >> plus } ;
  assignment:          { o | [ << variable >> ':= ] 0 seq1 } ;
  evaluation:          { o | [ << primary >>  << messages >> opt ] seq } ;
  primary:             { o | [ << variable >>   << nestedTerm >>  << nestedBlock >>  << .literal >> ] alt } ;
  variable:            { o | << identifier >> } ;
  messages:            { o | [ << unaryMessage >> star << .binaryMessage >> star << keywordMessage >> opt ] seq } ;
  unaryMessage:        { o | << unarySelector >> } ;
  binaryMessage:       { o | [ << binarySelector >>  << binaryOperand >> ] seq } ;
  binaryOperand:       { o | [ << primary >>  << unaryMessage >> star ] seq } ;
  keywordMessage:      { o | [ << keyword >>  << formula >> ] seq plus } ;
  formula:             { o | [ << binaryOperand >>  << binaryMessage >> star ] seq } ;
  nestedTerm:          { o | [ '( << expression >> ') ] 1 seq1 } ;
  literal:             { o | [ << literalArray >>  << literalSymbol >>  << literalString >>  << literalNumber >> ] alt } ;
  literalArray:        { o | [ '# '( << literal >> star ') ] 2 seq1 } ;
  literalNumber:       { o | << Number >> } ;
  literalSymbol:       { o | [ '# [ << string >>  << selector >> ] alt ] 1 seq1 tok } ;
  literalString:       { o | << STString >> } ;
  selector:            { o | [ << binarySelector >>  << keywordSelector >>  << unarySelector >> ] alt } ;
  keywordSelect2:      { o | << KeywordSeq >> } ;
  keywordSelector:     { o | << KeywordSeq >> } ;
  string:              { o | << STString >> } ;
  nestedBlock:         { o | [ '[  << blockPattern >> opt  << blockContents >> opt '] ] seq } ;
  blockPattern:        { o | [ << blockArguments >> '| ] 0 seq1 } ;
  blockArguments:      { o | [ " :" << argument >> ] seq joinp plus } ;
  //  Number:            { o | [ '- lit opt << Num >> plus [ '. << Num >> plus ] seq opt ] seq tok } ;
  Number:              { o | [ '- lit opt << Num >> plus joinp [ '. << Num >> plus joinp ] seq joinp opt ] seq { | { | } filter join $># } mapp tok } ; // $># only works with integers
  Alpha:               { o | [ `a `z range `A `Z range ] alt { | c>$ } mapp } ;
  Num:                 { o | `0 `9 range { | c>$ } mapp } ;
  AlphaNum:            { o | [ << Alpha >>  << Num >> ] alt } ;
  Identifier:          { o | [ << Alpha >>  << AlphaNum >> star joinp ] seq joinp tok } ;
  STPrimitive:         { o | 'primitive lit } ;
  Separator:           { o | '- lit 4 repeatp tok } ;
  OperatorSeq:         { o | '~&|*/\+<>,%@-= chars plus joinp } ;
  Keyword:             { o | [ << Identifier >> ': ] seq joinp tok } ;
  KeywordSeq:          { o | << Keyword >> plus joinp tok } ;
  STStringChar:        { o | [
    '\b  8 c>$ litMap // backspace
    '\t  9 c>$ litMap // tab
    '\n 10 c>$ litMap // newline
    '\f 12 c>$ litMap // formfeed
    '\r 13 c>$ litMap // carriage return
    '\' 39 c>$ litMap // single quote
    '\\ 92 c>$ litMap // backslash
    //      '\0 litMap // zero byte character, doesn't work well with C strings
    '' !chars ] alt } ;
  STString:            { o | [ '' << STStringChar >> star '' ] 1 seq1 joinp } ;
  Comment:             { o | [ '" '" !chars star '" ] 1 seq1 tok } ;
  Whitespace:          { o | [ tab cr nl sp ] alt plus joinp tok } ;
  ignore:              { o | [ << Whitespace >>  << Comment >> ] alt plus tok } ;
  | { s | (* 'method: .$ s .$ .nl *) s ?? (* dup ! { | 'unknown-method .$ .nl } if *) }
} () :SOMParser

// Macro too make it shorter to write semantic actions
// ! <name> <body> ;; -> name: { o | 'name o .super body mapp } ;
{ let sym :m ';; readUntil :body |
  ${ {{ m }}: { o | '{{ m }} o .super {{ body }} mapp } ; }$ emit
} :!!

// TODO: super needs to still pass correct 'o'
{ let _super_: SOMParser ;
  super: { m o | o m _super_ () () } ;

  // What each line would like like without the !! macro:
  // fields:            { o | 'fields o .super { | joins } mapp } ;

  ! fields              &joins ;;
  ! STPrimitive         {  a | "  { | }" } ;; // TODO: lookup primitive implementation
  ! blockContents       { a | a 0 @ { | [ " { let" a 0 @ { i | " 0 :" i + } do " |" a 1 @ " } ()" ] joins } { | a 1 @ } ifelse } ;;
  ! blockBodyReturn     { | "  ---<-" +$ } ;;
  ! blockBodyExpression &joins ;;
  ! formula             { a | a 0 @ a 1 @ joins +$ } ;;
  ! keywordMessage      { a | [ a { i | i 0 @ } map join a { i | i 1 @ } map joins a len ] } ;;
  ! binaryOperand       { a | a 0 @ a 1 @ joins + } ;;
  ! evaluation          &joins ;;
  ! unaryPattern        { a | [ a " " ] } ;;
  ! keywordPattern      { a | [ a { i | i 0 @ } map join  a { i | i 1 @ } map joins ] } ;;
  ! assignation         { a | [ a 1 @  a 0 @ { i | "  " } map " dup" joinWith a 0 @ join ] join } ;;
  ! messages            { a | [
    a 0 @ { i | '. i + } map joins
    a 1 @ { i | i 1 @ " swap ." i 0 @ +  } do
    a 2 @ { | a 2 1 @@  a 2 2 @@  'pick '. a 2 0 @@ + 'drop } if
  ] joins } ;;
  ! fields              { a | a { | a joins } { | " " } ifelse } ;;
  ! STString            { a | [ '" "  " a '" ] join } ;;
  ! superclass          { a | a { | a } { | 'Object } ifelse } ;;
  ! program             { a | a nl joinWith } ;;
  ! assignment          { a | "  :" a + } ;;
  ! nestedBlock         { a | [ '{ a 1 @ joins '| a 2 @ '} ] joins } ;;
  |
  { m | m ?? { | m _super_ () } || }
} () :SOMCompiler
