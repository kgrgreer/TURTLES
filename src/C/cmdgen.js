// cmdgen.js - generates cmds.h and cmds.c

const fs = require('node:fs');

var fnDefs = '', scopeDefs = '', declDefs = '', cmdToStr = '';

function sf(args, code) {
  var argDefs = args.split(',').reverse().map(a => `  long ${a} = (long) pop(stack);`).join('\n');
  var body    = code ? `  push(stack, (void*) (long) (${code}));` : '';

  return argDefs + '\n' + body;
}

function af(args, code) {
  var argDefs = args.split(',').reverse().map(a => `  long ${a} = (long) pop(stack);`).join('\n');

  return argDefs + '\n' + code;
}


[
  [ 'call',   '()',       af('i',     'callInstruction(i);') ],
  [ 'ret',    '<-',       '' ],
  [ 'plus',   '+',        sf('a,b',   'a+b')  ],
  [ 'minus',  '-',        sf('a,b',   'a-b')  ],
  [ 'mul',    '*',        sf('a,b',   'a*b')  ],
  [ 'div',    '/',        sf('a,b',   'a/b')  ],
  [ 'mod',    '%',        sf('a,b',   'a%b')  ],
  [ 'eq',     '=',        sf('a,b',   'a==b') ],
  [ 'neq',    '!=',       sf('a,b',   'a!=b') ],
  [ 'lt',     '<',        sf('a,b',   'a<b')  ],
  [ 'gt',     '!=',       sf('a,b',   'a>b')  ],
  [ 'lte',    '!=',       sf('a,b',   'a<=b') ],
  [ 'gte',    '!=',       sf('a,b',   'a>=b') ],
  [ 'not',    '!',        sf('a',     '!a')   ],
  [ 'and',    '&',        sf('a,b',   'a&&b') ],
  [ 'or',     '|',        sf('a,b',   'a||b') ],
  [ 'if',     'if',       af('c,b',   'if ( c ) callInstruction(b);') ],
  [ 'ifelse', 'ifelse',   af('c,i,e', 'callInstruction(c ? i : e);')  ],
  [ 'drop',   'drop',     'pop(stack);' ],
  [ 'andand', '&&',       'void* aFn = pop(stack); if ( ! pop(stack) ) { push(stack, (void*) 0); } else { push(stack, aFn); call_(); }' ],
  [ 'oror',   '||',       'void* aFn = pop(stack); if ( pop(stack) ) { push(stack, (void*) 1); } else { push(stack, aFn); call_(); }'   ],
  [ 'for',    'for',      af('s,e,b', `  for ( long i = s ; i <= e ; i++ ) { push(stack, (void*) i); callInstruction(b); }`)   ],
  [ 'while',  'while',    af('c,b', `  while ( true ) { callInstruction(c); if ( ! pop(stack) ) break; callInstruction(b); }`) ],
  [ 'now',    'now',      `struct timeval tp; gettimeofday(&tp, NULL); push(stack, (void*) (tp.tv_sec * 1000 + tp.tv_usec / 1000));` ],
  [ 'print',  'print',    af('a', `
    printf("\\n\\033[1;30m"); // Print in bold black
    printf("%ld", a);
    printf("\\033[0m");      // Revert colour code`)
  ],
  [ 'printStr', 'print$', af('a', `
    printf("\\n\\033[1;30m"); // Print in bold black
    printf("%s", (char *) a);
    printf("\\033[0m");      // Revert colour code`)
  ],

].forEach(i => {
  var [ name, op, code ] = i;
  name += '_';

  fnDefs += `
void ${name}() {
${code}
}
`;

  scopeDefs += `  scope = addFn(scope, "${op}", &${name});\n`;

  declDefs += `void ${name}();\n`;

  cmdToStr += `  if ( fn == &${name} ) return "${op}";\n`;
});


[
  [ 'constant',       'void* v',               'push(stack, v)', true ],
  [ 'autoConstant',   'void* v',               'push(stack, v); call_()', true ],
  [ 'frameReference', 'int frame,long offset', 'push(stack, (void*) heap->arr[frameOffset(frame, offset)])' ],
  [ 'frameSetter',    'int frame,long offset', 'heap->arr[frameOffset(frame, offset)] = pop(stack)' ],
  [ 'frameIncr',      'int frame,long offset', 'heap->arr[frameOffset(frame, offset)]++' ],
  [ 'frameDecr',      'int frame,long offset', 'heap->arr[frameOffset(frame, offset)]--' ],
  [ 'callClosure',    'long pfp,long fn', `
    long ofp = fp;

    fp = push(heap, (void*) pfp); // previous FP
    long ohp = heap->ptr;
    // printf("calling closure at: %ld, fp: %ld, fn: %ld, from: %ld\\n", closure, pfp, fn, ip);
    execute(fn);

    // Optimization, if nothing extra has been allocated on the heap, treat
    // it like a stack and revert back to position before pushing this frame.
    if ( heap->ptr == ohp ) heap->ptr = fp;

    fp = ofp;
    `
  ],
  [ 'createClosure',  'void* fn',              'push(stack, (void*) push3(heap, callClosure, (void*) fp, fn))' ],
].forEach(i => {
  var [ name, args, code, emit ] = i;

  var argDef = args.split(',').map(arg => {
    var [type, name] = arg.split(' ');
    return `  ${type} ${name} = (${type}) nextI();`;
  }).join('\n');

fnDefs += `void ${name}() {
${argDef}
${code};
}
`;

  if ( emit ) {
    // TODO: complete

    fnDefs += `
void emit${name[0].toUpperCase() + name.substring(1)}_() {
  push(code, ${name});
}
`;
  }

  declDefs += `void ${name}();`;
  cmdToStr += `  if ( fn == &${name} ) return "${name}";\n`;
});


fs.writeFileSync('cmds.h', `// cmds.h -- generated by cmdgen.js

Scope* addCmds(Scope* scope);

char* cmdToStr(Fn fn);

${declDefs}
`);



fs.writeFileSync('cmds.c', `// cmds.c -- generated by cmdgen.js

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/time.h>
#include "t0.h"
#include "globals.h"

${fnDefs}

Scope* addCmds(Scope* scope) {
${scopeDefs}
  return scope;
}

char* cmdToStr(Fn fn) {
${cmdToStr}

  return NULL;
}
`);
