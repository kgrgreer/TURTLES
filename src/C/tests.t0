nop ::prompt
clear

// Build a Tester class to perform tests and record statistics
// TODO: move to own file
// TODO: add colour support
// TODO: add padding

{ let 0 :passed 0 :failed |
  { m |
    m switch
      'score { f this |
        f { | passed++ passed " PASSED" } { | failed++ failed " FAILED" } ifelse
      }
      'test { script answer this |
        " Expect: " .$ script .$ "  -> " .$ answer . "  " .$
        script eval answer = this .score .$ .nl
      }
      'testf { f answer this |
        " Expect: " .$ '<function> .$ "  -> " .$ answer . "  " .$
        f () answer = this .score .$ .nl
      }
      'report { this |
        .nl
        " Tests Run: " .$ passed failed + . .nl
        "    PASSED: " .$ passed . .nl
        "    FAILED: " .$ failed . .nl
        .nl
      }
      { this | " unknown method: " .$ m .$ }
    end
  }
} ::Tester

Tester :t // Create an instance of Tester
{ | t .test }  ::test
{ | t .testf } ::testf

{ s | .nl s .$ "  -------------------------------" .$  .nl } ::section


'Strings section

// """ 'abc " abc" =$ """ true test // TODO: doesn't work
{ | 'abc " abc" =$ } true testf


'Logic section

" true  ! " false test
" false ! " true  test
" false false & " false test
" false true  & " false test
" true  false & " false test
" true  true  & " true  test
" false false | " false test
" false true  | " true  test
" true  false | " true  test
" true  true  | " true  test
" false { | false } && "  false test
" false { | true }  && "  false test
" true  { | false } && "  false test
" true  { | true }  && "  true  test
" false { | false } || "  false test
" false { | true }  || "  true  test
" true  { | false } || "  true  test
" true  { | true }  || "  true  test
" true false | true false & | " true test


'Comparators section

" 1 1 =  " true  test
" 1 2 =  " false test
" 1 1 != " false test
" 1 2 != " true  test
" 1 2 <  " true  test
" 2 1 <  " false test
" 2 2 <= " true  test
" 2 3 <= " true  test


'Arithmetic section

// TODO: bug space needed before end quotes
" 1 1 +        " 2 test
" 0 1 +        " 1 test
" 2 1 -        " 1 test
" 0 6 -        " -6 test
" 4 2 *        " 8 test
" 4 2 /        " 2 test
" 10 3 mod     " 1 test
" 2 8 ^        " 256 test
" 15 %         " 0.15 test
" 15 10 10 ^ * " 150000000000 test // scientific notation, distance from earth to sun in meters
" 5 neg        " -5 test


'Combinatorics section

" 1 fact  " 1 test
" 2 fact  " 2 test
" 10 fact " 3628800 test
" 20 fact " 2432902008176640000 test
" 10 2 P  " 90 test
" 10 2 C  " 45 test


'Stack section

" 1 2 drop    " 1 test
" 1 2 3 drop2 " 1 test
" 1 dup drop  " 1 test
" 2 10 swap / " 5 test


'Conditionals section
"   true  { | 1 } if             " 1 test
" 2 false { | 1 } if             " 2 test
"   true  { | 1 } { | 2 } ifelse " 1 test
"   false { | 1 } { | 2 } ifelse " 2 test


'Arrays section
// Array Literal
[ 1 2 3 ] :a
[ 4 5 6 ] :b
a .[] b .[] .nl

// Numbers 1 to 10
[ 1 10 { } for ] .[] .nl
// or
10 { } []WithFn .[] .nl

// 1 repeated 10 times
[ 1 10 { _ | 1 } for ] .[] .nl
// or
[ { | 1 } 10 repeat ] .[] .nl
// or
10 { _ | 1 } []WithFn .[] .nl
// or
10 1 []WithValue .[] .nl

// Clone a
[ a { } forEach ] .[] .nl
// or
a clone[] .[] .nl

// Concatenate a and b
[ a { } forEach b { } forEach ] .[] .nl
// or
a b +[] .[] .nl


'Return section
" { | 1 2 <- 3 4 5 } ()                    "  2 test
// TODO: fix
" { :o | 1 { | 10 o<- 11 } () 2 3 4 5 } () " 10 test // labelled return


" Function Programming" section
[ 1 10 { } for ] :a
a .[] .nl
a { c | c 2 mod 0 = } filter .[] .nl
" a 0 { | + } reduce " 55 test
a { v | v v * } map .[] .nl


" Own Variables" section
0 { count |
  { | count++ count }
} () ::counter

" counter " 1 test
" counter " 2 test
" counter " 3 test


'OO section
// Create a Lisp-like CONS operator, but use head/tail instead of car/cdr
// Is a simple class.
{ h t |
  { m |
    m switch
      'head  { this | h }
      ':head { v this | v :h }
      'tail  { this | t }
      ':tail { v this | v :t }
      { }
    end
  }
} ::cons

'car 'cdr cons :c // construct a cons
" c   'head c () () 'car =$ " true test
" c   'tail c () () 'cdr =$ " true test
"   c .head         'car =$ " true test
"   c .tail         'cdr =$ " true test
" 1 c .:head  c .head 1 =   " true test
" 2 c .:tail  c .tail 2 =   " true test


'Recursion section
{ n | n 1 <= { | 1 } { | n n 1 - factorial () * } ifelse } :factorial
" 20 factorial () " 2432902008176640000 test
{ f | { x | { y | y x x () () } f () } { x | x x () } () } :Y // y-combinator
{ f | { n | n 1 <= { | 1 } { | n n 1 - f () * } ifelse } } Y () :fact2
" 10 fact2 () " 3628800 test


" Auto Functions" section
" { | 1 } ::auto auto " 1 test
" &auto () " 1 test

t .report
