// a comment
1 1 + . // another comment
/*
  a multiline
  comment
*/
2 2 + .
5 132 + .
3.1415926 .
10 -1 + .
1 1 = .
1 0 = .
1 ! .
0 ! .
5 :five
five .
five five + .

// Logical Operators
1 1 = :true
1 0 = :false
false false & .
false true  & .
true  false & .
true  true  & .
false false | .
false true  | .
true  false | .
true  true  | .

// Forth-like stack operators
{ _ | } ::drop  { o | o o } ::dup  { a b | b a } ::swap

1 2 3 drop drop drop
42 dup dup dup . . . .
1 2 swap . .

// Closure Test
1000 { counter | { | counter++ counter } } () ::cc
cc cc cc cc cc

// Short-circuited logical operators
1 { | 2 . 1 } &&
0 { | 2 . 1 } &&
1 { | 2 . 1 } ||
0 { | 2 . 1 } ||

// if and ifElse
1 { | 666 . } if
0 { | 777 . } if

1 { | 100 . } { | 200 . } ifElse
0 { | 100 . } { | 200 . } ifElse

// Make your own if statement
{ flag block | flag block && } ::if2
1 { | 666 . } if2
0 { | 777 . } if2

// Make your own ifElse statement
{ flag ifBlock elseBlock | flag ifBlock && flag elseBlock || } ::ifElse2
1 { | 100 . } { | 200 . } ifElse2
0 { | 100 . } { | 200 . } ifElse2

// While loop
1 5 { start end | { | start end <= } { | start . start start++ } while } ()

// For loops

{ s e block | { | s e <= } { | s block () s++ } while } ::for
100 105 { i | i . } for

{ | guru 1000 1005 { i | i . } for } () // doesn't work

0 { count |
  1 1000 { i |
    i .
    1 1000 { j |
      drop
      count++
    } for
  } for
  count .
} ()
